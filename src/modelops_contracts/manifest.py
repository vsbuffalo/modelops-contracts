"""Bundle manifest for model discovery.

The BundleManifest provides a registry of available models for discovery
and task generation. This is generated by the science package and consumed
by infrastructure to understand what can be executed.
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, List

# Import ModelEntry from registry where it now lives
from .registry import ModelEntry


@dataclass(frozen=True)
class BundleManifest:
    """Manifest describing all models in a bundle.

    Provides a registry of available models for discovery and task generation.
    This is generated by the science package (e.g., modelops-calabaria) and
    consumed by infrastructure (e.g., modelops) to understand what can be executed.

    Attributes:
        bundle_ref: OCI reference or path to bundle
        bundle_digest: BLAKE2b-256 hash of entire bundle (64-char hex)
        models: Map of model identifiers to their metadata
        version: Manifest format version for compatibility
    """
    bundle_ref: str
    bundle_digest: str
    models: Dict[str, ModelEntry]
    version: int = 1

    def __post_init__(self):
        # Validate bundle_digest format
        if not self.bundle_digest:
            raise ValueError("bundle_digest must be non-empty")
        if not (len(self.bundle_digest) == 64 and
                all(c in "0123456789abcdef" for c in self.bundle_digest)):
            raise ValueError("bundle_digest must be 64-character hex string")

        # Validate bundle_ref
        if not self.bundle_ref:
            raise ValueError("bundle_ref must be non-empty")

        # Validate models
        if not self.models:
            raise ValueError("models must contain at least one model")

    def get_model_by_entrypoint(self, entrypoint_base: str) -> ModelEntry | None:
        """Look up a model by its entrypoint base.

        Args:
            entrypoint_base: Python import path like 'models.seir.StochasticSEIR'

        Returns:
            ModelEntry if found, None otherwise
        """
        return self.models.get(entrypoint_base)

    def list_all_entrypoints(self) -> List[str]:
        """Get all available entrypoint IDs across all models.

        Returns:
            List of all entrypoint IDs with scenarios
        """
        entrypoints = []
        for model in self.models.values():
            # Use the entrypoint from ModelEntry
            entrypoints.append(model.entrypoint)
            # Add scenario variations if they exist
            for scenario in model.scenarios:
                entrypoints.append(f"{model.entrypoint}/{scenario}")
        return sorted(entrypoints)


__all__ = ["BundleManifest"]