"""Batch and job types for grouped simulation execution.

These types enable efficient execution of multiple related simulations
as a batch, typically from parameter sweeps or sampling strategies.
"""

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional
import hashlib

from .simulation import SimTask
from .errors import ContractViolationError


@dataclass(frozen=True)
class SimBatch:
    """A batch of simulation tasks to run together.

    Groups related tasks that were generated by the same sampling method
    or parameter sweep. This is what science code generates when exploring
    parameter spaces or running sensitivity analyses.

    Attributes:
        batch_id: Unique identifier for this batch
        tasks: List of simulation tasks to execute
        sampling_method: Method used to generate tasks ("grid", "sobol", etc.)
        metadata: Additional metadata about the batch
    """
    batch_id: str
    tasks: List[SimTask]
    sampling_method: str
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        # Validate batch_id
        if not self.batch_id:
            raise ContractViolationError("batch_id must be non-empty")

        # Validate tasks
        if not self.tasks:
            raise ContractViolationError("tasks must contain at least one SimTask")

        for i, task in enumerate(self.tasks):
            if not isinstance(task, SimTask):
                raise ContractViolationError(
                    f"tasks[{i}] must be SimTask, got {type(task).__name__}"
                )

        # Validate sampling_method
        if not self.sampling_method:
            raise ContractViolationError("sampling_method must be non-empty")

        # Known sampling methods (for documentation, not strict validation)
        known_methods = {"grid", "sobol", "random", "lhs", "manual"}
        if self.sampling_method not in known_methods:
            # This is just a warning in metadata, not an error
            if "warnings" not in self.metadata:
                object.__setattr__(self, "metadata", {**self.metadata, "warnings": []})
            self.metadata["warnings"].append(f"Unknown sampling_method: {self.sampling_method}")

    def task_count(self) -> int:
        """Get the number of tasks in this batch."""
        return len(self.tasks)

    def compute_batch_hash(self) -> str:
        """Compute a hash representing all tasks in the batch.

        Returns:
            32-character hex string hash of all task parameters
        """
        # Hash based on all task param_ids for deduplication
        param_ids = [task.params.param_id for task in self.tasks]
        content = "|".join(sorted(param_ids))
        return hashlib.blake2b(content.encode(), digest_size=16).hexdigest()

# Note: SimJob has been moved to jobs.py with ABC-based design
# This module now only contains SimBatch

__all__ = ["SimBatch"]