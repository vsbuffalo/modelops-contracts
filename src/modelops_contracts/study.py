"""Study types for simulation experiments.

This module defines types for representing experimental designs
without execution details (no bundle references). These types
are used by sampling algorithms to generate parameter sweeps.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
import hashlib
import json
import uuid

from .types import UniqueParameterSet
from .simulation import SimTask
from .batch import SimBatch
from .jobs import SimJob


@dataclass(frozen=True)
class ParameterSet:
    """Pure parameter values without execution context.

    Represents a single point in parameter space.
    """
    params: Dict[str, Any]

    @property
    def param_id(self) -> str:
        """Generate deterministic ID from parameters.

        Returns:
            16-character hex string uniquely identifying these parameters
        """
        # Sort keys for deterministic serialization
        content = json.dumps(self.params, sort_keys=True)
        return hashlib.blake2b(content.encode(), digest_size=8).hexdigest()


@dataclass(frozen=True)
class SimulationStudy:
    """Abstract simulation study without execution details.

    This represents the experimental design - what to run and
    with which parameters, but not how (no bundle reference).
    Generated by sampling algorithms, then bound to a bundle
    at submission time.
    """
    model: str  # e.g., "models.seir"
    scenario: str  # e.g., "baseline"
    parameter_sets: List[ParameterSet]
    sampling_method: str  # "sobol", "grid", "manual"
    n_replicates: int = 1
    outputs: Optional[List[str]] = None  # Specific outputs to extract
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_simjob(self, bundle_ref: str, job_id: Optional[str] = None) -> SimJob:
        """Bind this study to a bundle to create executable SimJob.

        This is the key transformation that happens at submission time,
        converting an abstract study into a concrete job.

        Args:
            bundle_ref: Bundle reference (must be sha256:64-hex-chars)
            job_id: Optional job ID, auto-generated if not provided

        Returns:
            SimJob ready for execution

        Raises:
            ValueError: If bundle_ref format is invalid
        """
        # Validate bundle_ref format
        if not bundle_ref.startswith("sha256:") or len(bundle_ref) != 71:
            raise ValueError(
                f"bundle_ref must be sha256:64-hex-chars, got: {bundle_ref}"
            )

        # Create tasks for all parameter sets and replicates
        tasks = []
        for param_set in self.parameter_sets:
            for replicate_idx in range(self.n_replicates):
                # Create task with deterministic seed
                task = SimTask.from_components(
                    import_path=self.model,
                    scenario=self.scenario,
                    bundle_ref=bundle_ref,
                    params=param_set.params,
                    seed=self._generate_seed(param_set.param_id, replicate_idx),
                    outputs=self.outputs
                )
                tasks.append(task)

        # Create batch containing all tasks
        batch_id = f"{self.sampling_method}-{uuid.uuid4().hex[:8]}"
        batch = SimBatch(
            batch_id=batch_id,
            tasks=tasks,
            sampling_method=self.sampling_method,
            metadata={
                "n_parameter_sets": len(self.parameter_sets),
                "n_replicates": self.n_replicates,
                "model": self.model,
                "scenario": self.scenario,
                **self.metadata
            }
        )

        # Create job
        if not job_id:
            job_id = f"job-{uuid.uuid4().hex[:8]}"

        return SimJob(
            job_id=job_id,
            batches=[batch],
            bundle_ref=bundle_ref
        )

    def _generate_seed(self, param_id: str, replicate_idx: int) -> int:
        """Generate deterministic seed from param_id and replicate index.

        Args:
            param_id: Parameter set identifier
            replicate_idx: Replicate index (0-based)

        Returns:
            Seed value in uint32 range for reproducibility
        """
        content = f"{param_id}:{replicate_idx}"
        hash_bytes = hashlib.blake2b(content.encode(), digest_size=8).digest()
        # Use modulo to ensure seed fits in uint32 range
        return int.from_bytes(hash_bytes, 'big') % (2**32)

    def parameter_count(self) -> int:
        """Get number of unique parameter sets."""
        return len(self.parameter_sets)

    def total_simulation_count(self) -> int:
        """Get total number of simulations (params Ã— replicates)."""
        return len(self.parameter_sets) * self.n_replicates


@dataclass(frozen=True)
class CalibrationSpec:
    """Specification for a calibration study.

    Defines the configuration for an adaptive parameter search
    without execution details. Converted to CalibrationJob at
    submission time.
    """
    model: str
    scenario: str
    algorithm: str  # "optuna", "abc-smc"
    target_data: Dict[str, Any]
    max_iterations: int
    convergence_criteria: Dict[str, float] = field(default_factory=dict)
    algorithm_config: Dict[str, Any] = field(default_factory=dict)
    outputs: Optional[List[str]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


__all__ = [
    "ParameterSet",
    "SimulationStudy",
    "CalibrationSpec",
]