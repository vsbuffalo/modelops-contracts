"""Study types for simulation experiments.

This module defines types for representing experimental designs
without execution details (no bundle references). These types
are used by sampling algorithms to generate parameter sweeps.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
import hashlib
import uuid

from .types import UniqueParameterSet, make_param_id
from .simulation import SimTask
from .jobs import SimJob


@dataclass(frozen=True)
class SimulationStudy:
    """Abstract simulation study without execution details.

    This represents the experimental design - what to run and
    with which parameters, but not how (no bundle reference).
    Generated by sampling algorithms, then bound to a bundle
    at submission time.

    Attributes:
        model: Module path to simulation class (e.g., "models.seir")
        scenario: Scenario name (e.g., "baseline")
        parameter_sets: List of parameter dictionaries to evaluate
        sampling_method: How parameters were generated ("sobol", "grid", "manual")
        n_replicates: Number of replicates per parameter set
        outputs: Specific outputs to extract (None = all)
        metadata: Additional study metadata
    """
    model: str
    scenario: str
    parameter_sets: List[Dict[str, Any]]  # Plain dicts, no wrapper
    sampling_method: str
    n_replicates: int = 1
    outputs: Optional[List[str]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_simjob(self, bundle_ref: str, job_id: Optional[str] = None) -> SimJob:
        """Bind this study to a bundle to create executable SimJob.

        This is the key transformation that happens at submission time,
        converting an abstract study into a concrete job.

        Args:
            bundle_ref: Bundle reference (must be sha256:64-hex-chars)
            job_id: Optional job ID, auto-generated if not provided

        Returns:
            SimJob ready for execution

        Raises:
            ValueError: If bundle_ref format is invalid
        """
        # Validate bundle_ref format
        if not bundle_ref.startswith("sha256:") or len(bundle_ref) != 71:
            raise ValueError(
                f"bundle_ref must be sha256:64-hex-chars, got: {bundle_ref}"
            )

        # Create tasks for all parameter sets and replicates
        tasks = []
        for param_dict in self.parameter_sets:
            # Get stable parameter ID for this parameter set
            param_id = make_param_id(param_dict)

            for replicate_idx in range(self.n_replicates):
                # Create task with deterministic seed
                task = SimTask.from_components(
                    import_path=self.model,
                    scenario=self.scenario,
                    bundle_ref=bundle_ref,
                    params=param_dict,  # from_components will create UniqueParameterSet
                    seed=self._generate_seed(param_id, replicate_idx),
                    outputs=self.outputs
                )
                tasks.append(task)

        # Create job directly with tasks (no batch wrapper)
        if not job_id:
            job_id = f"job-{uuid.uuid4().hex[:8]}"

        # Store study metadata in job
        job_metadata = {
            "sampling_method": self.sampling_method,
            "n_parameter_sets": len(self.parameter_sets),
            "n_replicates": self.n_replicates,
            "model": self.model,
            "scenario": self.scenario,
            **self.metadata
        }

        return SimJob(
            job_id=job_id,
            tasks=tasks,  # Direct tasks list, no batch!
            bundle_ref=bundle_ref,
            metadata=job_metadata
        )

    def _generate_seed(self, param_id: str, replicate_idx: int) -> int:
        """Generate deterministic seed from param_id and replicate index.

        Args:
            param_id: Parameter set identifier
            replicate_idx: Replicate index (0-based)

        Returns:
            Seed value in uint32 range for reproducibility
        """
        content = f"{param_id}:{replicate_idx}"
        hash_bytes = hashlib.blake2b(content.encode(), digest_size=8).digest()
        # Use modulo to ensure seed fits in uint32 range
        return int.from_bytes(hash_bytes, 'big') % (2**32)

    def parameter_count(self) -> int:
        """Get number of unique parameter sets."""
        return len(self.parameter_sets)

    def total_simulation_count(self) -> int:
        """Get total number of simulations (params Ã— replicates)."""
        return len(self.parameter_sets) * self.n_replicates


@dataclass(frozen=True)
class CalibrationSpec:
    """Specification for a calibration study.

    Defines the configuration for an adaptive parameter search
    without execution details. Converted to CalibrationJob at
    submission time.
    """
    model: str
    scenario: str
    algorithm: str  # "optuna", "abc-smc"
    target_data: Dict[str, Any]
    max_iterations: int
    convergence_criteria: Dict[str, float] = field(default_factory=dict)
    algorithm_config: Dict[str, Any] = field(default_factory=dict)
    outputs: Optional[List[str]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


__all__ = [
    "SimulationStudy",
    "CalibrationSpec",
]